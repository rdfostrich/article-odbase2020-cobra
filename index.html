<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Optimizing Storage of RDF Archives&lt;br /&gt;using Bidirectional Delta Chains</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="Optimizing Storage of RDF Archives<br />using Bidirectional Delta Chains">
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Thibault Mahieu" />
  <meta name="citation_author" content="Martin Vanbrabant" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2021/09/22" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="optimizing-storage-of-rdf-archivesbr-using-bidirectional-delta-chains">Optimizing Storage of RDF Archives<br />using Bidirectional Delta Chains</h1>
  <div id="repeating-title">Optimizing Storage of RDF Archives<br />using Bidirectional Delta Chains</div>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="#" typeof="foaf:Person schema:Person" resource="#">Thibault Mahieu</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="#" typeof="foaf:Person schema:Person" resource="https://data.knows.idlab.ugent.be/person/martinvanbrabant#me">Martin Vanbrabant</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec
          <br />E-mail: ruben.taelman@ugent.be</li>
  </ul>

  <div class="reviewers">
<strong>Editor(s):</strong> Aidan Hogan, Universidad de Chile, Chile
<br />
<strong>Solicited reviews:</strong> Johannes Frey, Leipzig University, Germany; Christoph Lange, Fraunhofer FIT, Germany
</div>

  <section class="context">
    <h2 id="in-reply-to">In reply to</h2>
    <ul>
      <li><a href="https://linkedresearch.org/calls" rel="as:inReplyTo">Call for Linked Research</a></li>
      <li><a href="http://www.semantic-web-journal.net/calls" rel="as:inReplyTo">SWJ call for papers</a></li>
    </ul>
  </section>
</header>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>Linked Open Datasets on the Web that are published as RDF can evolve over time.
There is a need to be able to store such evolving RDF datasets,
and query across their versions.
Different storage strategies are available for managing such versioned datasets,
each being efficient for specific types of versioned queries.
In recent work, a hybrid storage strategy has been introduced that combines these different strategies
to lead to more efficient query execution for all versioned query types at the cost of increased ingestion time.
While this trade-off is beneficial in the context of Web querying,
it suffers from exponential ingestion times in terms of the number of versions,
which becomes problematic for RDF datasets with many versions.
<!-- Need         -->
As such, there is a need for an improved storage strategy that scales better in terms of ingestion time for many versions.
<!-- Task         -->
We have designed, implemented, and evaluated a change to the hybrid storage strategy
where we make use of a <em>bidirectional delta chain</em>
instead of the default <em>unidirectional delta chain</em>.
<!-- Object       -->
In this article,
we introduce a concrete architecture for this change,
together with accompanying ingestion and querying algorithms.
<!-- Findings     -->
Experimental results from our implementation
show that the ingestion time is significantly reduced.
As an additional benefit,
this change also leads to lower total storage size and even improved query execution performance in some cases.
<!-- Conclusion   -->
This work shows that modifying the structure of delta chains within the hybrid storage strategy
can be highly beneficial for RDF archives.
<!-- Perspectives -->
In future work,
other modifications to this delta chain structure deserve to be investigated,
to further improve the scalability of ingestion and querying of datasets with many versions.</p>

      <p><span id="keywords"><span class="title">Keywords:</span> Linked Data, RDF archiving, Semantic Data Versioning, storage, indexing</span></p>

    </div>
</section>


<div class="double-column">

<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Introduction</h2>

          <p>Even though the <a property="schema:citation http://purl.org/spar/cito/cites" href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">RDF</a> <span class="references">[<a href="#ref-1">1</a>]</span> data model itself is atemporal,
RDF datasets typically change over time <span class="references">[<a href="#ref-2">2</a>]</span>.
Such changes can include additions,
modifications, or deletions of individual facts, ontologies, or even complete datasets.
While some evolving datasets such as DBpedia <span class="references">[<a href="#ref-3">3</a>]</span>
are published as separate dumps per version,
more direct and efficient access to prior versions can be desired,
so that versioned queries in, between, and across different versions can be done efficiently.</p>

          <p>While RDF archiving systems have emerged in the past that can handle such evolving datasets,
<a property="schema:citation http://purl.org/spar/cito/cites" href="http://ceur-ws.org/Vol-1377/paper6.pdf">a survey on archiving Linked Open Data</a> <span class="references">[<a href="#ref-4">4</a>]</span>
illustrated the need for improved versioning capabilities
in order to preserve RDF on the Web and expose queryable access.
Concretely, there is a need for systems that can store and query such datasets with low cost and effort on Web servers,
so that they can cope with the large scale of RDF datasets on the Web, and their velocity of changes.
In previous work, we introduced a <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">new hybrid archiving approach, implemented as a system called OSTRICH</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>.
The approach enables efficient triple pattern queries for different versioned query types,
while still keeping storage requirements reasonable.
OSTRICH was designed to run on average machines,
so it can be used as a back-end for low-cost Web query interfaces such as <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/doi:10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Triple Pattern Fragments</a></span> <span class="references">[<a href="#ref-6">6</a>]</span>.
Since it exposes a triple pattern query interface,
it can also be used as an index inside <a property="schema:citation http://purl.org/spar/cito/cites" href="http://www.w3.org/TR/2013/REC-sparql11-query-20130321/">SPARQL query engines</a> <span class="references">[<a href="#ref-7">7</a>]</span>.
As such, this hybrid storage approach is a step towards solving the need for properly preserving RDF on the Web.</p>

          <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.3233/SW-210434"><a href="https://content.iospress.com/articles/semantic-web/sw210434">A recent survey</a></span> <span class="references">[<a href="#ref-8">8</a>]</span>
has shown that existing RDF archiving solutions fail to handle large RDF archives with many versions.
It was shown that the hybrid approach employed by OSTRICH is the only one capable of storing large RDF archives,
but that it suffers from a scalability issue in terms of ingestion time for many versions.
This is an inherent consequence of the storage strategy of OSTRICH, which is employed to achieve performant query execution.
Concretely, after ingesting many versions, the ingestion process starts slowing down significantly,
which makes OSTRICH unusable for datasets with a large number of versions,
which is crucial for preserving RDF datasets on the Web.
The reason for this is that the hybrid storage approach from OSTRICH only consists of a single version <em>snapshot</em> at the start,
followed by an <em>aggregated delta chain</em> that keeps growing longer for every new version.
While this aggregated delta chain is beneficial for faster query execution,
it comes at the cost of increased ingestion times.
Since additional deltas lead to a cumulative increase in aggregated delta size during ingestion,
this process becomes more memory-intensive and slower for every new version.
In order to delay this problem, we propose a storage strategy modification,
where there still is a single version snapshot,
but we place it in the middle of the delta chain,
instead of at the beginning,
leading to a <em>bidirectional delta chain</em>.
This modification is inspired by the concept of <em>bidirectional predicted pictures</em> (B-frames) <span class="references">[<a href="#ref-9">9</a>]</span>
that are a popular technique within video compression.
Typically, such B-frames are used for non-aggregated deltas,
but we instead devise a similar technique for aggregated deltas.
While bidirectional delta chains complicate ingestion and querying,
it leads to two shorter delta chains.
This will require less effort than one long delta chain,
and may lead to faster ingestion and querying.</p>

          <p>In the next section, we discuss the related work,
and give more details on OSTRICH.
Next, in <a href="#problem-statement">Section 3</a>, we present our problem statement,
followed by our proposed solution in <a href="#solution">Section 4</a>.
After that, we present our experimental setup and results in <a href="#evaluation">Section 5</a>,
and we conclude in <a href="#conclusions">Section 6</a>.</p>

        </div>
</section>

  <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Related Work</h2>

          <p>In this section, we discuss the fundamentals on RDF archiving,
which RDF archiving solutions already exist,
and benchmarks for RDF archiving.
Finally, we discuss OSTRICH in more detail,
since we build upon this approach in this work.</p>

          <h3 id="rdf-archiving">RDF Archiving</h3>

          <p>Various techniques have been introduced to store <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2013.01.002"><a href="http://www.websemanticsjournal.org/index.php/ps/article/view/328">RDF datasets</a></span> <span class="references">[<a href="#ref-10">10</a>, <a href="#ref-11">11</a>]</span>.
These techniques make use of various indexing and compression techniques
to optimize query execution and storage size.
There is a need to maintain the history of these datasets <span class="references">[<a href="#ref-2">2</a>, <a href="#ref-4">4</a>]</span>,
which gave rise to the research domain of <em>RDF archiving</em>.
An <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.3233/SW-180309"><a href="http://semantic-web-journal.org/system/files/swj1814.pdf"><em>RDF archive</em></a></span> <span class="references">[<a href="#ref-12">12</a>]</span> has been defined as <em>a set of version-annotated triples.</em>
Where a <em>version-annotated triple</em> is defined as <em>an RDF triple with a label representing the version in which this triple holds.</em>
Furthermore, an RDF version of an RDF archive is composed of all triples with a given version label.</p>

          <p>RDF archives allow multiple versions to exist in parallel,
which leads to a range of new querying possibilities.
Instead of only querying within the latest version of a dataset,
also previous versions can be queried,
or even differences between different versions.
To cover this new range of querying possibilities,
<span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.3233/SW-180309"><a href="http://semantic-web-journal.org/system/files/swj1814.pdf">five foundational query types were introduced</a></span> <span class="references">[<a href="#ref-12">12</a>]</span>,
which are referred to as <em>query atoms</em>.
For brevity, we refer to <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.3233/SW-180309"><a href="http://semantic-web-journal.org/system/files/swj1814.pdf">the article in which they were introduced</a></span> <span class="references">[<a href="#ref-12">12</a>]</span> for their formal details.
In the scope of this article, we only discuss three of the five query atoms,
as the other two query atoms can be expressed in <a property="schema:citation http://purl.org/spar/cito/cites" href="http://rubensworks.net/raw/publications/2016/ExposingRdfArchivesUsingTpf.pdf">terms of just three query atoms</a> <span class="references">[<a href="#ref-13">13</a>]</span>.
The three relevant query atoms are defined as follows:</p>

          <ol>
            <li><strong>Version materialization (VM)</strong> retrieves data using a query targeted at a single version.
Example: <em>Which books were present in the library yesterday?</em></li>
            <li><strong>Delta materialization (DM)</strong> retrieves query result change sets between two versions.
Example: <em>Which books were returned or taken from the library between yesterday and now?</em></li>
            <li><strong>Version query (VQ)</strong> annotates query results with the versions in which they are valid.
Example: <em>At what times was book X present in the library?</em></li>
          </ol>

          <h3 id="rdf-archiving-solutions">RDF Archiving Solutions</h3>

          <p>In the recent years, several techniques and solutions have been proposed to allow storing and querying RDF archives.
RDF archiving systems are typically categorized into <a property="schema:citation http://purl.org/spar/cito/cites" href="http://ceur-ws.org/Vol-1377/paper6.pdf">four non-orthogonal storage strategies</a> <span class="references">[<a href="#ref-4">4</a>, <a href="#ref-14">14</a>]</span>:</p>

          <ul>
            <li>The <strong>Independent Copies (IC)</strong> approach creates separate instantiations of datasets for
each change or set of changes.</li>
            <li>The <strong>Change-Based (CB)</strong> approach instead only stores change sets between versions.</li>
            <li>The <strong>Timestamp-Based (TB)</strong> approach stores the temporal validity of facts.</li>
            <li>The <strong>Fragment-based (FB)</strong> approach stores snapshots of each changed <em>fragment</em> of datasets.</li>
          </ul>

          <figure id="rdf-archive-systems" class="table">

            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>IC</th>
                  <th>CB</th>
                  <th>TB</th>
                  <th>FB</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>SemVersion <span class="references">[<a href="#ref-15">15</a>]</span></td>
                  <td>✓</td>
                  <td> </td>
                  <td> </td>
                  <td> </td>
                </tr>
                <tr>
                  <td>Cassidy et al. <span class="references">[<a href="#ref-16">16</a>]</span></td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                  <td> </td>
                </tr>
                <tr>
                  <td>R&amp;WBase <span class="references">[<a href="#ref-17">17</a>]</span></td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                  <td> </td>
                </tr>
                <tr>
                  <td>R43ples <span class="references">[<a href="#ref-18">18</a>]</span></td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                  <td> </td>
                </tr>
                <tr>
                  <td>Hauptman et al. <span class="references">[<a href="#ref-19">19</a>]</span></td>
                  <td> </td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                </tr>
                <tr>
                  <td>X-RDF-3X <span class="references">[<a href="#ref-20">20</a>]</span></td>
                  <td> </td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                </tr>
                <tr>
                  <td><a property="schema:citation http://purl.org/spar/cito/cites" href="https://pdfs.semanticscholar.org/8efc/acc920a6329bda5508c65c84d69f52eb5ac1.pdf">RDF-TX</a> <span class="references">[<a href="#ref-21">21</a>]</span></td>
                  <td> </td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                </tr>
                <tr>
                  <td>v-RDFCSA <span class="references">[<a href="#ref-22">22</a>]</span></td>
                  <td> </td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                </tr>
                <tr>
                  <td>Dydra <span class="references">[<a href="#ref-23">23</a>]</span></td>
                  <td> </td>
                  <td> </td>
                  <td>✓</td>
                  <td> </td>
                </tr>
                <tr>
                  <td><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.002"><a href="https://arxiv.org/pdf/1805.03721">Quit Store</a></span> <span class="references">[<a href="#ref-14">14</a>]</span></td>
                  <td> </td>
                  <td> </td>
                  <td> </td>
                  <td>✓</td>
                </tr>
                <tr>
                  <td>TailR <span class="references">[<a href="#ref-24">24</a>]</span></td>
                  <td>✓</td>
                  <td>✓</td>
                  <td> </td>
                  <td> </td>
                </tr>
                <tr>
                  <td><a property="schema:citation http://purl.org/spar/cito/cites" href="https://users.dcc.uchile.cl/~ahogan/docs/sparql-version.pdf">Cuevas et al.</a> <span class="references">[<a href="#ref-25">25</a>]</span></td>
                  <td>✓</td>
                  <td>✓</td>
                  <td>✓</td>
                  <td> </td>
                </tr>
                <tr>
                  <td><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">OSTRICH</a></span> <span class="references">[<a href="#ref-5">5</a>]</span></td>
                  <td>~</td>
                  <td>✓</td>
                  <td>✓</td>
                  <td> </td>
                </tr>
              </tbody>
            </table>

            <figcaption>
              <p><span class="label">Table 1:</span> Overview of RDF archiving solutions with their corresponding storage strategy:
Individual copies (IC), Change-based (CB), Timestamp-based (TB), or Fragment-based (FB).
✓: fullfils the strategy completely; ~: fullfils the strategy partially.</p>
            </figcaption>
          </figure>

          <p>There exists a correspondence between these query atoms
and the independent copies (IC), change-based (CB), timestamp-based (TB) and fragment-based (FB) storage strategies.
Namely, IC and FB typically lead to efficient VM queries,
CB is better for DM queries,
and TB is best for VQ queries.
No single strategy leads to good performance of all query atoms.</p>

          <p><a href="#rdf-archive-systems">Table 1</a> shows an overview of the primary RDF archiving systems,
and which storage strategy they follow. These are explained in more detail hereafter.</p>

          <h4 id="independent-copies-approaches">Independent copies approaches</h4>
          <p>SemVersion <span class="references">[<a href="#ref-15">15</a>]</span> tracks different versions of RDF graphs,
using Concurrent Versions System (CVS) concepts to maintain different versions of ontologies,
such as diff, branching and merging.</p>

          <h4 id="change-based-approaches">Change-based approaches</h4>
          <p>Cassidy et al. <span class="references">[<a href="#ref-16">16</a>]</span> propose a system to store changes to graphs as a series of patches, which makes it a CB approach.
They describe operations on versioned graphs such as reverse, revert and merge.
A preliminary evaluation shows that their implementation is significantly slower
than a native RDF store.
Im et al. <span class="references">[<a href="#ref-26">26</a>]</span> propose a CB patching system based on a relational database.
In their approach, they use a storage scheme called <em>aggregated deltas</em>
which associates the latest version with each of the previous ones.
While aggregated deltas result in fast delta queries, they introduce a higher storage overhead.
R&amp;WBase <span class="references">[<a href="#ref-17">17</a>]</span> is a CB versioning system that uses the graph component of quad-stores to build a versioning layer.
It supports tagging, branching and merging.
R43ples <span class="references">[<a href="#ref-18">18</a>]</span> follows a similar approach to R&amp;WBase,
but they additionally introduce new SPARQL keywords, such as <code>REVISION</code>, <code>BRANCH</code> and <code>TAG</code>.</p>

          <h4 id="timestamp-based-approaches">Timestamp-based approaches</h4>
          <p>Hauptman et al. <span class="references">[<a href="#ref-19">19</a>]</span> store each triple in a different named graph,
which corresponds to the TB storage approach.
The identifying graph of each triple is used in a commit graph for SPARQL query evaluation at a certain version.
X-RDF-3X <span class="references">[<a href="#ref-20">20</a>]</span> is a versioning extension of RDF-3X <span class="references">[<a href="#ref-11">11</a>]</span>,
where each triple is annotated with a creation and deletion timestamp.
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://pdfs.semanticscholar.org/8efc/acc920a6329bda5508c65c84d69f52eb5ac1.pdf">RDF-TX</a> <span class="references">[<a href="#ref-21">21</a>]</span> is an in-memory query engine that supports a temporal SPARQL querying extension,
which makes use of a compressed multi-version B+Tree that outperforms similar systems such as X-RDF-3X in terms of querying efficiency,
while having similar storage requirements.
v-RDFCSA <span class="references">[<a href="#ref-22">22</a>]</span> is a self-indexing RDF archive mechanism
that enables versioning queries on top of compressed RDF archives as a TB approach.
Dydra <span class="references">[<a href="#ref-23">23</a>]</span> is an RDF graph storage platform with dataset versioning support.
They introduce the <code>REVISION</code> keyword, which is similar to the SPARQL keyword <code>GRAPH</code> for referring to different dataset versions.</p>

          <h4 id="fragment-based-approaches">Fragment-based approaches</h4>
          <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.002"><a href="https://arxiv.org/pdf/1805.03721">Quit Store</a></span> <span class="references">[<a href="#ref-14">14</a>]</span> is a system that is built on top of Git,
which allows these same features by considering each version to be a commit.
A version is made up of multiple fragments, which may be reused across multiple versions of a dataset,
which typically leads to lower storage space compared to a pure IC strategy.
Using Git’s delta compression, this storage space can be reduced even further at the cost of slower querying.</p>

          <h4 id="hybrid-approaches">Hybrid approaches</h4>
          <p>TailR <span class="references">[<a href="#ref-24">24</a>]</span> is an HTTP archive for Linked Data pages for retrieving prior versions of certain HTTP resources.
It is a hybrid CB/IC approach as it starts by storing a dataset snapshot,
after which only deltas are stored for each consecutive version.
When the chain becomes too long, or other conditions are fulfilled,
a new snapshot is created for the next version to avoid long version reconstruction times.
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://users.dcc.uchile.cl/~ahogan/docs/sparql-version.pdf">Cuevas et al.</a> <span class="references">[<a href="#ref-25">25</a>]</span> propose an approach similar to R&amp;WBase,
where the named graph functionality in SPARQL 1.1 engines is used to store RDF archives,
and versioned queries are achieved through query rewriting.
As opposed to R&amp;WBase which only uses a CB approach, they propose distinct a IC strategy, four CB strategies, and a TB strategy.
For each of those strategies, they introduce separate query rewriting techniques for VM and DM queries,
but do not consider VQ queries.
Experimental results on an archive with eight large versions show there is a time-space trade-off,
whereby large storage sizes achieve faster query execution,
and smaller storage sizes result in slower query execution.
The authors consider the TB strategy achieving the best trade-off.
Relevant for our work is the use of four CB strategies,
which correspond to forward, backward deltas, forward aggregated <span class="references">[<a href="#ref-26">26</a>]</span>, and backward aggregated deltas.
<span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">OSTRICH</a></span> <span class="references">[<a href="#ref-5">5</a>]</span> is a hybrid IC/CB/TB approach that exploits the advantages of each strategy
to provide a trade-off between storage requirements and querying efficiency.
It only fullfils the IC strategy partially,
since it only creates a fully materialized snapshot for the first version,
and stores differences afterwards.
Experiments show that OSTRICH achieves good querying performance for all query atoms,
but suffers from scalability issues in terms of ingestion time for many versions.
As such, we build upon OSTRICH in this work, and attempt to solve this problem.</p>

          <h3 id="rdf-archiving-benchmarks">RDF Archiving Benchmarks</h3>

          <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.3233/SW-180309"><a href="http://semantic-web-journal.org/system/files/swj1814.pdf">BEAR</a></span> <span class="references">[<a href="#ref-12">12</a>]</span> is a benchmark for RDF archive systems
that is based on real-world datasets from different domains.
The 58 versions of BEAR-A contain between 30M and 66M triples per version, with an average change ratio of 31%.
BEAR-A provides triple pattern queries for three different query atoms for both result sets with a low and a high cardinality.
The BEAR-B dataset contains the 100 most volatile resources from DBpedia Live at three different granularities (instant, hour and day),
and provides a small collection of triple pattern queries corresponding to the real-world usage of DBpedia.
Each version contains between 33K and 43K triples, where the instant granularity has an average change ratio of 0.011%,
hour has 0.304%, and day has 1.252%.
Given the relative number of triples and change ratios between BEAR-A and BEAR-B,
we refer to BEAR-A as a dataset with few large versions,
and to BEAR-B as a dataset with many small versions for the remainder of this article.</p>

          <p>The BEAR benchmark also provides baseline RDF archive implementations based on <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2013.01.002"><a href="http://www.websemanticsjournal.org/index.php/ps/article/view/328">HDT</a></span> <span class="references">[<a href="#ref-10">10</a>]</span> and
Jena’s <span class="references">[<a href="#ref-27">27</a>]</span> <a href="https://jena.apache.org/documentation/tdb/">TDB store</a>
for the IC, CB, and TB approaches, and the hybrid IC/CB and TB/CB approaches.
Just like TailR <span class="references">[<a href="#ref-24">24</a>]</span>, the hybrid approaches are based on snapshots followed by delta chains.
Since HDT does not support quads by default, the TB and TB/CB approaches were not implemented in the HDT baseline implementations.
Given the variety of these approaches in terms of storage strategies,
together with their open availability and ease of use,
they form a good basis for comparative analysis when benchmarking,
which is why we make use of them during our experiments.</p>

          <p>Due to BEAR covering all query atoms we work with,
and it providing baseline implementations for the different storage strategies,
we make use of BEAR for our experiments.</p>

          <h3 id="ostrich">OSTRICH</h3>

          <p>As mentioned before, <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">OSTRICH</a></span> <span class="references">[<a href="#ref-5">5</a>]</span> makes use of a hybrid IC/CB/TB storage approach
with the goal of providing a trade-off between storage size and querying efficiency.
The main motivation for OSTRICH is to serve as a back-end of a <a property="schema:citation http://purl.org/spar/cito/cites" href="http://rubensworks.net/raw/publications/2017/vtpf.pdf">low-cost Web APIs for exposing RDF archives</a> <span class="references">[<a href="#ref-28">28</a>]</span>,
where query execution must be sufficiently fast,
without requiring too much storage.</p>

          <p>Concretely, OSTRICH always starts by storing the initial version as a fully materialized version, following the IC strategy.
This initial version is stored using <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2013.01.002"><a href="http://www.websemanticsjournal.org/index.php/ps/article/view/328">HDT</a></span> <span class="references">[<a href="#ref-10">10</a>]</span>, which enables high compression and efficient querying.
Based on this initial version, all following versions are stored as deltas, following the CB strategy.
To solve the problem of increasing query execution times for increasing numbers of versions,
OSTRICH makes use of the aggregated deltas <span class="references">[<a href="#ref-26">26</a>]</span> approach,
by making each delta relative to the initial snapshot instead of the previous version.
Due to the storage redundancies that are introduced because of these aggregated deltas,
OSTRICH uses a B+tree-based approach to store all aggregated deltas in a single store.
This single store annotates each added and deleted triple with the delta version in which it exists,
thereby following the timestamp-based strategy.
To further reduce storage requirements and query execution times,
all triple components inside this store are dictionary-encoded, similar to the approach followed by HDT.</p>

          <p>On top of this storage approach, OSTRICH introduces algorithms for VM, DM and VQ triple pattern queries.
Only triple pattern queries are supported instead of full SPARQL queries,
since triple pattern queries are the foundational building blocks for more expressive SPARQL queries.
These query algorithms produce streaming results, where the streams can start from an arbitrary offset,
which is valuable for SPARQL query features such as <code>OFFSET</code> and <code>LIMIT</code>.
Additionally, OSTRICH provides algorithms for cardinality estimation for these queries,
which are valuable for query planning within query engines.
OSTRICH has been implemented in <a href="https://github.com/rdfostrich/ostrich">C/C++</a>,
with bindings existing for <a href="https://github.com/rdfostrich/ostrich-node">Node.JS (JavaScript)</a>.
The triple pattern index provided by OSTRICH has been demonstrated
to be usable within a full SPARQL query engine such as <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1007/978-3-030-00668-6_15"><a href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a></span> <span class="references">[<a href="#ref-29">29</a>, <a href="#ref-30">30</a>]</span>.</p>

          <p>Experimental results on OSTRICH with the BEAR benchmark show that this hybrid strategy
is more beneficial than having just a single storage strategy,
as it allows efficient execution of all query atoms.
The main downside of this approach is that it leads to scalability issues in terms of ingestion time for many versions.
Concretely, the BEAR-B-hourly dataset—which contains 1,299 versions—
starts showing high ingestion times starting around version 1,100.
The reason for this is that the aggregated deltas start becoming too large.
As such, we aim to resolve this problem in this work by improving the hybrid storage strategy from OSTRICH
through fundamental changes to the delta chain structure.</p>

        </div>
</section>

  <section id="problem-statement" inlist="" rel="schema:hasPart" resource="#problem-statement">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Problem Statement</h2>

          <p>As mentioned in <a href="#introduction">Section 1</a>, RDF archiving solutions are not sufficiently capable of handing large RDF archives with many versions.
While the hybrid storage approach as proposed by OSTRICH can handle the largest archives among all currently existing approaches,
it does not scale sufficiently to a large number of versions due to its long delta chains.
Our goal in this work is to investigate if we can build on top of this hybrid storage approach
and modify its delta chain structure
to be able to handle RDF archives with more versions.</p>

          <p>We formulate our research question as follows:
<q id="research-question">How can we improve the storage of RDF archives under the hybrid storage strategy by modification of the delta chain structure?</q></p>

          <p>Concretely, we start from the hybrid storage approach from OSTRICH,
and we modify its current (forward) <em>unidirectional delta chain</em> (UDC) into a <em>bidirectional delta chain</em> (BDC).
This bidirectional delta chain consists of two smaller delta chains,
with respectively reverse and forward deltas, all pointing to one common intermediary snapshot.
Since these modifications will reduce the maximum length of a delta chain, without requiring more snapshots,
we expect that this will reduce ingestion time, overall storage size, and query execution time for all query atoms.
Under the assumption of typical RDF archives provided by standard RDF archiving benchmarks,
we define the following hypotheses:</p>

          <ol>
            <li id="hypothesis-qualitative-storage">Storage size is lower for a BDC compared to a UDC.</li>
            <li id="hypothesis-qualitative-ingestion">In-order ingestion time is lower for a BDC compared to a UDC.</li>
            <li id="hypothesis-qualitative-querying-vm">VM query execution is faster for a BDC compared to a UDC.</li>
            <li id="hypothesis-qualitative-querying-dm">DM query execution is faster for a BDC compared to a UDC.</li>
            <li id="hypothesis-qualitative-querying-vq">VQ query execution is faster for a BDC compared to a UDC.</li>
          </ol>

        </div>
</section>

  <section id="solution" inlist="" rel="schema:hasPart" resource="#solution">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Bidirectional Delta Chain</h2>

          <p>In this section, we explain our bidirectional delta chain approach.
We start by explaining the general idea behind a bidirectional delta chain.
After that, we explain its implication on storage.
Finally, we discuss querying algorithms for the foundational query atoms based on this storage approach.</p>

          <h3 id="solution-approaches">Delta Chain Approaches</h3>

          <p>In the scope of this work, we distinguish between 6 different delta chain approaches,
as can be seen in <a href="#delta-chain-approaches">Table 2</a>.
We decompose these approaches into 2 axes: <em>directionality</em> and <em>aggregation</em>.</p>

          <figure id="delta-chain-approaches" class="table">

            <table class="delta-approaches">
              <thead>
                <tr>
                  <th style="text-align: right"> </th>
                  <th style="text-align: center"><strong>Non-aggregated</strong></th>
                  <th style="text-align: center"><strong>Aggregated</strong></th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td style="text-align: right"><strong>Forward<br /> UDC</strong></td>
                  <td style="text-align: center"><span><img src="img/delta-chain-uni.svg" alt="Unidirectional delta chain" class="delta-approach delta-approach-left" /></span></td>
                  <td style="text-align: center"><span><img src="img/delta-chain-uni-agg.svg" alt="Unidirectional aggregated delta chain" class="delta-approach" /></span></td>
                </tr>
                <tr>
                  <td style="text-align: right"><strong>Reverse<br /> UDC</strong></td>
                  <td style="text-align: center"><span><img src="img/delta-chain-uni-rev.svg" alt="Unidirectional reverse delta chain" class="delta-approach delta-approach-left" /></span></td>
                  <td style="text-align: center"><span><img src="img/delta-chain-uni-agg-rev.svg" alt="Unidirectional aggregated reverse delta chain" class="delta-approach" /></span></td>
                </tr>
                <tr>
                  <td style="text-align: right"><strong>BDC</strong><br /> </td>
                  <td style="text-align: center"><span><img src="img/delta-chain-bi.svg" alt="Bidirectional delta chain" class="delta-approach delta-approach-left" /></span></td>
                  <td style="text-align: center"><span><img src="img/delta-chain-bi-agg.svg" alt="Bidirectional aggregated delta chain" class="delta-approach" /></span></td>
                </tr>
              </tbody>
            </table>

            <figcaption>
              <p><span class="label">Table 2:</span> Overview of unidirectional forward, unidirectional reverse, and bidirectional delta chain approaches,
both with and without aggregated deltas.</p>
            </figcaption>
          </figure>

          <p>Along the <em>directionality</em> axis, we distinguish 3 forms:</p>

          <ol>
            <li>The simplest form is the <strong>forward unidirectional</strong> delta chain,
where the snapshot comes first, and is followed by deltas that are relative to the previous delta.</li>
            <li>The <strong>reverse unidirectional</strong> delta chain is a variant of this where everything is reversed.
Concretely, the snapshot comes last, and is preceded by deltas, where each delta is relative to the next delta.</li>
            <li>These forward and reverse unidirectional approaches can be combined with each other to form a <strong>bidirectional delta chain</strong>,
where a first set of deltas exists before the snapshot,
and a second set of deltas exists after the snapshot.</li>
          </ol>

          <p>Along the <em>aggregation</em> axis, we consider 2 forms:</p>

          <ul>
            <li>In the <strong>non-aggregated form</strong>, each delta is relative to the delta immediately before or after it.</li>
            <li>In the <strong>aggregated form</strong> <span class="references">[<a href="#ref-26">26</a>]</span>, each delta is relative to the snapshot before or after it,
where other deltas may occur in-between.</li>
          </ul>

          <p>The aggregated delta approach leads to lower version materialization times,
since each delta can be directly applied to a snapshot,
as opposed to non-aggregated deltas where multiple deltas need to be combined before a version can be materialized.
As such, the version materialization time for aggregated deltas is <code>O(1)</code> with respect to the number of versions,
while it is <code>O(n)</code> for non-aggregated deltas with respect to the number of versions.
This shows how aggregated deltas lead to better query execution times.
The major downside of aggregated deltas is however that storage size increases due to the redundancies between the different deltas.
The longer the delta chain, the larger these redundancies become.</p>

          <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">OSTRICH</a></span> <span class="references">[<a href="#ref-5">5</a>]</span> is an example that follows the unidirectional forward aggregated delta chain approach,
while RCS <span class="references">[<a href="#ref-31">31</a>]</span> (non-RDF-based) follows the unidirectional reverse non-aggregated delta chain approach.
In this work, we will investigate the use of the <em>bidirectional aggregated</em> delta chain approach,
for reasons explained in the next section.</p>

          <h3 id="solution-bidirectional">Motivations for a Bidirectional Delta Chain</h3>

          <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">Experiments on the unidirectional forward aggregated delta chain approach from OSTRICH</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>
have shown that this approach leads to ingestion times
that increase linearly with chain length, assuming (non-aggregated) deltas as inputs.
This is an expected consequence of the aggregated delta approach,
as they grow in size for each new version.
The goal of this work is to investigate how these problems can be solved,
without losing the advantages of aggregated deltas with respect to query execution times.
We would not achieve any lower ingestion times by reversing our delta chain,
as the additions and deletions would just be swapped, but would not be smaller.
Instead, we aim to reduce ingestion time by lowering storage through the reduction of the number of required snapshots.</p>

          <p>One straightforward way of reducing ingestion time would be
to create a new snapshot and delta chain once the ingestion time or size has crossed a certain threshold.
One example of such a threshold could be that a new snapshot is created
once the ingestion time of a delta became larger than the time for ingesting a snapshot.
For instance, we can lower the total ingestion time to half the original time
by splitting one delta chain into two delta chains,
or even to one third by splitting it up into three delta chains.
In the extreme, each version would form its own snapshot,
which would lead to the independent copies storage strategy,
at the cost of increased storage size.
As such, there is a trade-off between ingestion time and storage size,
and new delta chains should only be started once ingestion times become higher than desired.</p>

          <p>Since the creation of a snapshot can be costly in terms of storage size,
it should be avoided until absolutely necessary.
As explained in the previous paragraph,
splitting up a delta chain into two separate delta chains
would lead to two snapshots, each followed by a chain of deltas.
We can however reduce the number of required snapshots
by combining the forward and reverse approaches into a <em>bidirectional</em> approach,
by allowing two sets of deltas to make use of the same snapshot.
Intuitively, one bidirectional delta chain is equivalent
to two forward delta chains,
where the second delta chain is reversed.
The snapshots of these two chains are therefore shared,
so that it only has to be created and stored once.</p>

          <p>As such, the main advantage of a bidirectional delta chain is that it can more efficiently make use of snapshots.
Instead of only allowing deltas in one direction to make use of it,
also deltas in the opposite direction can make use of it.
This is especially advantageous for aggregated deltas,
as these grow in size for longer chains.
In the scope of this research,
we continue working with a bidirectional <em>aggregated</em> delta chain
due to the non-increasing query execution times for increasing numbers of versions.</p>

          <p>One disadvantage of the bidirectional approach is that it complicates ingestion,
since we can not build a reverse delta chain directly,
as we can not always know beforehand what a future version will look like.
We tackle this problem in <a href="#solution-ingestion">Subsection 4.4</a>.</p>

          <h3 id="solution-storage">Storage Approach</h3>

          <p>As mentioned before, our goal is to improve storage efficiency of RDF archives.
For this, we build on top of the hybrid storage approach from OSTRICH,
and we fundamentally modify this storage approach to use a bidirectional aggregated delta chain
instead of a unidirectional aggregated delta chain.
Concretely, this means that not only deltas exist <em>after</em> the snapshot,
but also <em>before</em> the snapshot.</p>

          <figure id="storage-overview" class="figure">
<img src="img/storage-overview.svg" alt="Storage overview" class="storage-overview" />
<figcaption>
              <p><span class="label">Fig. 1:</span> Overview of the main components of our storage approach consisting of a bidirectional aggregated delta chain.</p>
            </figcaption>
</figure>

          <p><a href="#storage-overview">Fig. 1</a> shows an overview of the main components of our storage approach.
Note in particular the delta chain on the left side of the snapshot,
while OSTRICH only has a single delta chain on the right side of the snapshot.
All other components are inherited from OSTRICH,
which we briefly summarize in the next paragraph.</p>

          <p>We store the snapshot using <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2013.01.002"><a href="http://www.websemanticsjournal.org/index.php/ps/article/view/328">HDT</a></span> <span class="references">[<a href="#ref-10">10</a>]</span>,
due to its highly performant triple pattern queries, cardinality estimates,
and high compression rate.
Furthermore, metadata about the archive is stored, containing details such as the total number of versions.
To avoid storage overhead due to redundancies between different aggregated deltas,
each delta chain is compressed into timestamp-based B+tree indexes
where additions and deletions are stored separately.
This separation is done to speed up query evaluation since additions and deletions are not always needed at the same time.
To enable efficient triple pattern queries for all possible combinations,
each addition and deletion index is stored three times for different triple components orders (SPO, POS, OSP).
To compress each triple component further, a shared dictionary is used.
In order to allow efficient cardinality estimate retrieval for deletions,
the SPO deletion index contains additional metadata about the relative position of each triple inside the snapshot.
To enable cardinality estimates for additions, we make use of a dedicated addition count index.
For the sake of brevity, we omit further details about the components that can be found in the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">OSTRICH article (section 5)</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>.</p>

          <h3 id="solution-ingestion">Ingestion Approach</h3>

          <p>In this section, we introduce an approach to enable ingestion of new versions within our <em>bidirectional</em> aggregated storage approach.
For this, we build upon the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">streaming ingestion algorithm and DM query algorithm for <em>unidirectional</em> forward aggregated delta chains</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>,
which allows us to insert deltas <em>after</em> the snapshot.</p>

          <p>In order to insert deltas <em>before</em> the snapshot,
our approach for constructing the reverse delta chain involves a temporary forward delta chain.
This is because we can not start building our reverse delta chain directly,
as we can not predict what triples will be in the snapshot later down the line.
For each new version, our temporary forward delta chain will be built up,
and can be queried in the meantime.
From the moment that this delta chain becomes too long, or some other threshold has been exceeded,
then an offline fix-up algorithm is triggered that will effectively <em>reverse</em> this delta chain,
and place a snapshot at the end, where a new forward delta chain can be built upon when new versions arrive.</p>

          <figure id="algorithm-fixup" class="algorithm numbered">
<pre><code>FUNCTION fixUp(store)
</code><code># Recreate deltas, but in reverse
</code><code>  additions = [] 
</code><code>  deletions = []
</code><code>  FOR v IN store.getVersions()
</code><code>    deletions.push(store.getAdditions(v, v + 1))
</code><code>    additions.push(store.getDeletions(v, v + 1))
</code><code># Ingest reversed deltas into a new delta chain
</code><code>  newChain = store.newDeltaChain({ reversed: true })
</code><code>  FOR v IN store.getVersions()
</code><code>    newChain.ingest(v, additions[v], deletions[v])
</code><code># Replace delta chain
</code><code>  existingChain = store.getDeltaChain(store.getVersions())
</code><code>  store.replaceChain(existingChain, newChain)
</code></pre>
<figcaption>
              <p><span class="label">Algorithm 1:</span> Fix-up algorithm for reversing an existing bidirectional aggregated delta chain.</p>
            </figcaption>
</figure>

          <p><a href="#algorithm-fixup">Algorithm 1</a> shows a sketch of our fix-up algorithm in pseudo-code.
First, the aggregated deltas in the chain will be extracted as non-aggregated deltas by invoking <a href="https://rdfostrich.github.io/article-jws2018-ostrich/#delta-materialization">a DM query over the current unidirectional aggregated delta chain</a>.
We store the deletions as additions, and the additions as deletions.
Next, we create a new delta chain, and insert these reversed non-aggregated deltas by invoking <a href="https://rdfostrich.github.io/article-jws2018-ostrich/#ingestions">the streaming ingestion algorithm to create unidirectional aggregated delta chains</a>.
Once ingestion is done, the existing delta chain is replaced by our new delta chain.</p>

          <p>The main advantage of this fix-up approach is that it avoids query unavailability of the archive.
The fix-up algorithm can run at any time, preferably when the server is experiencing a lower query load.
During the execution of this process, the temporary forward delta chain is still available,
so queries are still possible during this time.
Only after the fix-up process is done,
query executions will be delegated to this new reverse delta chain, 
and the temporary forward delta chain can be deleted.
Since this fix-up process only applies to the first (temporary) delta chain,
and does not touch the second delta chain,
it may even run in parallel to other ingestion processes for new versions.</p>

          <h3 id="solution-ingestion-outoforder">Out-of-order Ingestion Approach</h3>

          <p>The previously discussed ingestion approach assumes in-order ingestion of versions,
where versions are ingested as soon as they become available.
In some cases, it may occur that all versions are present beforehand,
and can be ingested at the same time.
If this occurs, we can simplify ingestion and avoid the fix-up algorithm, by not inserting versions in their logical order.</p>

          <figure id="algorithm-outoforder-ingest" class="algorithm numbered">
<pre><code>FUNCTION ingestOutOfOrder(store, versions)
</code><code># Create snapshot for middle version
</code><code>  vMiddle = Math.floor(versions.length / 2)
</code><code>  store.createSnaphot(middleVersion, versions[vMiddle])
</code><code># Create reverse delta chain
</code><code>  reverseChain = store.newDeltaChain({ reversed: true, snapshot: vMiddle })
</code><code>  FOR v = 0; v &lt; vMiddle; v++
</code><code>    reverseChain.ingest(v, versions.deletions[v], versions.additions[v])
</code><code># Create forward delta chain
</code><code>  forwardChain = store.newDeltaChain({ reversed: false, snapshot: vMiddle })
</code><code>  FOR v = vMiddle + 1; v &lt; versions.length; v++
</code><code>    forwardChain.ingest(v, versions.additions[v], versions.deletions[v])
</code></pre>
<figcaption>
              <p><span class="label">Algorithm 2:</span> Out-of-order ingestion algorithm for creating a bidirectional aggregated delta chain for a predetermined set of versions.</p>
            </figcaption>
</figure>

          <p><a href="#algorithm-outoforder-ingest">Algorithm 2</a> shows a sketch of our out-of-order algorithm in pseudo-code.
Concretely, if we have a set of <code>n</code> versions
then we first determine the middle version <code>⌊n/2⌋</code>.
For this middle version, we create a fully materialized snapshot, and assign its proper version label <code>⌊n/2⌋</code>.
Next, we create our reverse delta chain for all versions <code>&lt; ⌊n/2⌋</code>,
by invoking <a href="https://rdfostrich.github.io/article-jws2018-ostrich/#ingestions">the streaming ingestion algorithm to create unidirectional aggregated delta chains</a> targeted at snapshot <code>⌊n/2⌋</code>, and by swapping the addition and deletion labels.
Finally, we create our forward delta chain for all versions <code>&gt; ⌊n/2⌋</code>,
by again invoking <a href="https://rdfostrich.github.io/article-jws2018-ostrich/#ingestions">the streaming ingestion algorithm to create unidirectional aggregated delta chains</a>
targeted at snapshot <code>⌊n/2⌋</code>.</p>

          <p>This out-of-order ingestion will typically not be used in a live setting.
Instead, it can be used when initializing an archive when all versions are known beforehand.</p>

          <h3 id="solution-query">Query Algorithms</h3>

          <p>In this section, we discuss triple pattern query algorithms for the three query atoms discussed in <a href="#related-work">Section 2</a> (VM, DM, VQ).
For simplicity, we assume the existence of a (bidirectional) delta chain with one snapshot.
We consider multiple snapshots and delta chains future work.
We build upon the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">existing algorithms for unidirectional (aggregated) delta chains</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>,
and thereby inherit their properties of streaming, offset support, and cardinality estimators.
Below, we briefly discuss the relevant parts of these existing algorithms.
For more details, we refer to the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">OSTRICH article (section 7)</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>.</p>

          <h4 id="version-materialization">Version Materialization</h4>

          <p>Version Materialization (VM) allows retrieval of triples in a given version.
In summary, <a href="https://rdfostrich.github.io/article-jws2018-ostrich/#version-materialization">VM over a unidirectional delta chain</a>
works by either querying a snapshot directly, if the requested version is a snapshot,
or applying a given delta on the closest preceding snapshot otherwise.
In our bidirectional delta chain, a snapshot can not only exist before a delta, but also after a delta.
Nevertheless, the algorithm itself remains the same as for a unidirectional delta chain,
as the delta will have to be applied onto the snapshot in both cases.
As such, we do not discuss this VM case any further.</p>

          <h4 id="delta-materialization">Delta Materialization</h4>

          <p>Delta Materialization (DM) allows differences between two given versions to be retrieved.
<a href="https://rdfostrich.github.io/article-jws2018-ostrich/#delta-materialization">The DM algorithm over a unidirectional delta chain distinguishes two cases for this</a>;
either the start version is a snapshot or a delta,
where the end version will always be a delta.
If the start (or end) version is a snapshot, then the result is simply a query within the aggregated delta of the end version.
Otherwise, the addition and deletion indexes for the two delta versions are iterated in a sort-merge join-like operation,
and only emit the triples that have a different addition/deletion flag for the two versions.</p>

          <p>In our bidirectional storage approach, one additional case can occur:
when the start and end version correspond to deltas in the bidirectional delta chain <em>before</em> and <em>after</em> the snapshot,
i.e., the DM query crosses the snapshot boundary.
For this, we split up our query into two queries:
a DM query from the start version until the snapshot,
and a DM query from the snapshot until the end version.
These two queries can be resolved over the two respective delta chains using <a href="https://rdfostrich.github.io/article-jws2018-ostrich/#delta-materialization">the DM algorithm over a unidirectional delta chain</a>.
As the OSTRICH DM algorithm guarantees that the triples from these two queries are sorted (because the are stored in order),
we can merge them in a sort-merge join way (which preserves the order),
where triples are only emitted if they don’t exist in both streams (ignoring the addition/deletion flag).
<a href="#algorithm-querying-dm">Algorithm 3</a> illustrates this algorithm in pseudocode.
Following the patch notation for <a property="schema:citation http://purl.org/spar/cito/cites" href="http://darcs.net">DARCS</a> <span class="references">[<a href="#ref-32">32</a>]</span>,
with <code>o</code> being the start version, <code>e</code> being the end version and <code>s</code> being the snapshot,
our delta split corresponds to <sup><code>o</code></sup><code>D</code><sup><code>e</code></sup> = <sup><code>o</code></sup><code>D1</code><sup><code>s</code></sup><code>D2</code><sup><code>e</code></sup>.</p>

          <figure id="algorithm-querying-dm" class="algorithm numbered">
<pre><code>FUNCTION queryDmCase3(store, start, end)
</code><code>  snapshotVersion = store.getSnapshotBetween(start, end)
</code><code>  reverseStream = store.getDeltaStream(start, snapshotVersion)
</code><code>  forwardStream = store.getDeltaStream(snapshotVersion, end)
</code><code>  return sortMerge(reverseStream, forwardStream)
</code></pre>
<figcaption>
              <p><span class="label">Algorithm 3:</span> Delta Materialization algorithm for triple patterns that produces a triple stream
when the version range crosses the snapshot boundary.</p>
            </figcaption>
</figure>

          <p>In order to estimate the cardinality of this third case,
the same idea is followed
where the counts of the part of the delta chain before and after the snapshot are added.
Just like the existing DM cardinality estimator over a unidirectional delta chain,
this can be an overestimation, since certain triples may occur in both delta chains
that would be omitted from the final result stream.</p>

          <h4 id="version-query">Version Query</h4>

          <p>A Version Query (VQ) enables querying across all versions,
with results being annotated with the versions in which they occur.
<a href="https://rdfostrich.github.io/article-jws2018-ostrich/#version-query">VQ over a unidirectional delta chain</a>
is done by iterating over the snapshot for a given triple pattern in a streaming manner.
Every snapshot triple is queried within the deletion index.
For every discovered deletion, their respective version annotations are removed from the result.
If no such deletion value was found, the triple was never deleted, so the versions annotation will contain all versions of the store.
Once the snapshot stream has finished,
the addition index are iterated in a similar way,
where the version annotation of every addition triple is again updated based on its presence in the deletion index.</p>

          <p>Our case is a trivial extension of this algorithm.
Instead of checking single addition and deletion streams,
two addition and deletion streams have to be checked.
This will produce distinct version annotations, for which we apply the union.</p>

          <p>To estimate the cardinality of the VQ results, the unidirectional delta chain approach can again be extended
by adding the snapshot cardinality with the addition cardinality for both delta chains for the given triple pattern.
As some triples could occur in both delta chains, this can lead to an overestimation.</p>

        </div>
</section>

  <section id="evaluation" inlist="" rel="schema:hasPart" resource="#evaluation">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Evaluation</h2>

          <p>In this section, we evaluate our bidirectional archiving approach by comparing our implementation to native OSTRICH and other systems.</p>

          <h3 id="evaluation-implementation">Implementation</h3>

          <p>We have implemented our storage approach and query algorithms as a tool called COBRA (Change-Based Offset-Enabled Bidirectional RDF Archive).
COBRA is an extension of OSTRICH, has been implemented in C/C++, and is available under the MIT license on <a href="https://github.com/rdfostrich/cobra" class="mandatory" data-link-text="https:/​/​github.com/​rdfostrich/​cobra">GitHub</a>.
Our implementation uses <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2013.01.002"><a href="http://www.websemanticsjournal.org/index.php/ps/article/view/328">HDT</a></span> <span class="references">[<a href="#ref-10">10</a>]</span> as snapshot technology,
and makes use of the highly efficient memory-mapped B+Tree implementation <a href="http://fallabs.com/kyotocabinet/" class="mandatory" data-link-text="http:/​/​fallabs.com/​kyotocabinet/​">Kyoto Cabinet</a> for storing our indexes.
The delta dictionary is encoded with <a href="http://www.gzip.org/">gzip</a>, which requires decompression during querying and ingestion.</p>

          <h3 id="evaluation-setup">Experimental Setup</h3>

          <p>In order to evaluate the ingestion and triple pattern query execution of COBRA,
we make use of the <a href="https://aic.ai.wu.ac.at/qadlod/bear.html" class="mandatory" data-link-text="https:/​/​aic.ai.wu.ac.at/​qadlod/​bear.html">BEAR benchmark</a>.
To test the scalability of our approach for datasets with few and large versions, we use the BEAR-A benchmark.
We use the first ten versions of the BEAR-A dataset (more versions cause memory issues with OSTRICH),
which contains 30M to 66M triples per version.
This dataset was compiled from the <a href="http://swse.deri.org/dyldo/">Dynamic Linked Data Observatory</a>.
To test for datasets with many smaller versions, we use BEAR-B with the daily and hourly granularities.
For the daily dataset we use 89 versions and for hourly dataset 1,299 versions,
both of them have around 48K triples per version.
All experiments were performed on a 64-bit Ubuntu 14.04 machine with a 24-core 2.40 GHz CPU and 128 GB of RAM.
Our experimental setup and its raw results are available on <a href="https://github.com/rdfostrich/cobra/tree/master/Experiments/" class="mandatory" data-link-text="https:/​/​github.com/​rdfostrich/​cobra/​tree/​master/​Experiments/​">GitHub</a>,
as well as <a href="https://github.com/rdfostrich/cobra-bear-results/" class="mandatory" data-link-text="https:/​/​github.com/​rdfostrich/​cobra-​bear-​results/​">the scripts that were used to process them</a>.</p>

          <p>Considering we aim to measure the benefits of the bidirectional aggregated delta chain
compared to the unidirectional aggregated delta chain under the hybrid storage strategy,
we primarily distinguish between the following storage approaches:</p>

          <ul>
            <li><strong>OSTRICH</strong>: Forward unidirectional aggregated delta chain (<a href="#evaluation-storage-approaches-ostrich">Subfig. 2.1</a>)</li>
            <li><strong>COBRA*</strong>: Bidirectional aggregated delta chain before fix-up (<a href="#evaluation-storage-approaches-cobra-star">Subfig. 2.2</a>)</li>
            <li><strong>COBRA</strong>: Bidirectional aggregated delta chain after fix-up (<a href="#evaluation-storage-approaches-cobra">Subfig. 2.3</a>)</li>
          </ul>

          <figure id="evaluation-storage-approaches" class="figure">

<figure id="evaluation-storage-approaches-ostrich" class="subfigure">
<img src="img/delta-chain-uni-agg.svg" alt="OSTRICH storage approach" class="eval-storage-approach" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 2.1:</span> OSTRICH with a forward unidirectional aggregated delta chain    </p>
              </figcaption>
</figure>

<figure id="evaluation-storage-approaches-cobra-star" class="subfigure">
<img src="img/delta-chain-bi-agg-before-fixup.svg" alt="COBRA* storage approach" class="eval-storage-approach" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 2.2:</span> COBRA* with two unidirectional aggregated delta chains <em>before</em> fix-up    </p>
              </figcaption>
</figure>

<figure id="evaluation-storage-approaches-cobra" class="subfigure">
<img src="img/delta-chain-bi-agg.svg" alt="COBRA storage approach" class="eval-storage-approach" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 2.3:</span> COBRA with a bidirectional aggregated delta chain <em>after</em> fix-up (ingested out-of-order starting with snapshot)</p>
              </figcaption>
</figure>

<figcaption>
              <p><span class="label">Fig. 2:</span> The different storage approaches used in our experiments for an arbitrary dataset with six versions.</p>
            </figcaption>
</figure>

          <p>In order to achieve a more complete comparison with other approaches,
we also evaluate BEAR’s Jena (IC, CB, TB and hybrid CB/TB) and HDT-based (IC and CB) RDF archive baseline implementations.
We consider a comparison with other systems such as X-RDF-3X, RDF-TX and Dydra
out of scope for this work due to the major difficulties we experienced with these systems
caused by missing implementations or the additional required implementation effort to support the required query interfaces.</p>

          <p>In the scope of this work, we work with at most two delta chains.
For simplicity of these experiments, we always start a new delta chain in the middle version of the dataset
(5 for BEAR-A, 45 for BEAR-B Daily, 650 for BEAR-B Hourly).
Note that for the COBRA storage approach, we assume that all versions are available beforehand,
so they can be stored out of order, starting with the middle snapshot.
For example, following the out-of-order ingestion algorithm from <a href="#solution-ingestion-outoforder">Subsection 4.5</a>,
for BEAR-A, this will first lead to the creation of a snapshot for version 5,
the creation of a reverse delta chain for versions 0-4,
and finally the creation of a forward delta chain for versions 6-9.
In practice, this may not always be possible, which is why we report on the additional fix-up time during ingestion separately
that would be required when ingesting in order (COBRA*).</p>

          <p>To evaluate triple pattern query performance,
we make use of the query sets provided by BEAR.
BEAR-A provides 7 query sets containing around 100 triple patterns that are further divided into high result cardinality and low result cardinality by the benchmark creators. 
BEAR-B provides two query sets that contain <code>?P?</code> and <code>?PO</code> queries.
We evaluate these queries as VM queries for all version, DM queries between the first and all other versions and a VQ query.
In order to minimize outliers, we replicate the queries five times and take the mean results.
Furthermore, we perform a warm-up period before the first query of each triple pattern.
Since neither OSTRICH nor COBRA support arbitrary numbers of snapshots,
we limit our experiments to OSTRICH’s unidirectional storage layout and COBRA’s bidirectional storage layout with a single snapshot.</p>

          <h3 id="evaluation-results">Measurements</h3>

          <p>In this section, we discuss the results of our experiments on ingestion and query evaluation,
which we then analyze in the next section.</p>

          <h4 id="ingestion">Ingestion</h4>

          <p><a href="#table-ingestion-size">Table 3</a> and <a href="#table-ingestion-time">Table 4</a> respectively show the total storage sizes and ingestion times
for BEAR-A, BEAR-B Daily, and BEAR-B Hourly under the different storage approaches.</p>

          <p>When purely comparing the COBRA approaches and OSTRICH, it can be observed that
COBRA requires less storage space than OSTRICH for BEAR-A and BEAR-B Hourly, but not for BEAR-B Daily.
COBRA* requires more storage space than both COBRA and OSTRICH with BEAR-A, but it requires less ingestion time.
For BEAR-B Daily, OSTRICH requires less storage, but COBRA* has the lowest ingestion time.
For BEAR-B Hourly, COBRA* is lower in terms of storage size and ingestion time than both COBRA and OSTRICH.
The outliers that are apparent for BEAR-B Hourly are compression artefacts for the storage of dictionaries and delta chains using Kyoto Cabinet,
as storage size may fluctuate slightly based on the available data.
In summary, COBRA requires less ingestion time than OSTRICH in all cases (59% less on average),
and it reduces storage size for two out of the three cases (19% lower on average).</p>

          <p>Compared to the HDT and Jena-based approaches,
and the original raw representation of BEAR’s delta files in N-Triples and gzip,
we see similar results as shown before in <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2018.08.001"><a href="https://rdfostrich.github.io/article-jws2018-ostrich/">the OSTRICH article (section 8.3.1)</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>.
COBRA, COBRA*, and OSTRICH reduce storage size compared to the raw gzip representation, expect for BEAR-A.
HDT-CB is consistently smaller, and Jena-CB/TB is also smaller for the BEAR-B datasets.
Regarding ingestion time, OSTRICH and COBRA are overall significantly slower than the alternatives.
However, COBRA speeds up ingestion enough so that it comes close to some of the Jena-based approaches,
and sometimes even becomes faster than them.</p>

          <figure id="table-ingestion-size" class="table">

            <table>
              <thead>
                <tr>
                  <th>Approach</th>
                  <th style="text-align: right">BEAR-A</th>
                  <th style="text-align: right">BEAR-B Daily.</th>
                  <th style="text-align: right">BEAR-B Hourly</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Raw (N-Triples)</td>
                  <td style="text-align: right">46,069.76</td>
                  <td style="text-align: right">556.44</td>
                  <td style="text-align: right">8,314.86</td>
                </tr>
                <tr>
                  <td>Raw (gzip)</td>
                  <td style="text-align: right"><strong>3,194.88</strong></td>
                  <td style="text-align: right">30.98</td>
                  <td style="text-align: right">466.35</td>
                </tr>
                <tr>
                  <td>OSTRICH</td>
                  <td style="text-align: right">4,587.52</td>
                  <td style="text-align: right">16.87</td>
                  <td style="text-align: right">450.59</td>
                </tr>
                <tr>
                  <td>COBRA</td>
                  <td style="text-align: right">4,066.74</td>
                  <td style="text-align: right">25.69</td>
                  <td style="text-align: right">331.20</td>
                </tr>
                <tr>
                  <td>COBRA*</td>
                  <td style="text-align: right">5,052.67</td>
                  <td style="text-align: right">21.58</td>
                  <td style="text-align: right">216.95</td>
                </tr>
                <tr>
                  <td>Jena-IC</td>
                  <td style="text-align: right">32,808.96</td>
                  <td style="text-align: right">415.32</td>
                  <td style="text-align: right">6,233.92</td>
                </tr>
                <tr>
                  <td>Jena-CB</td>
                  <td style="text-align: right">18,216.96</td>
                  <td style="text-align: right">42.82</td>
                  <td style="text-align: right">473.41</td>
                </tr>
                <tr>
                  <td>Jena-TB</td>
                  <td style="text-align: right">82,278.4</td>
                  <td style="text-align: right">23.61</td>
                  <td style="text-align: right">3,678.89</td>
                </tr>
                <tr>
                  <td>Jena-CB/TB</td>
                  <td style="text-align: right">31,160.32</td>
                  <td style="text-align: right">22.83</td>
                  <td style="text-align: right">53.84</td>
                </tr>
                <tr>
                  <td>HDT-IC</td>
                  <td style="text-align: right">6,829.73</td>
                  <td style="text-align: right">148.61</td>
                  <td style="text-align: right">2,226.45</td>
                </tr>
                <tr>
                  <td>HDT-CB</td>
                  <td style="text-align: right">3,485.43</td>
                  <td style="text-align: right"><strong>6.21</strong></td>
                  <td style="text-align: right"><strong>25.14</strong></td>
                </tr>
              </tbody>
            </table>

            <figcaption>
              <p><span class="label">Table 3:</span> Total storage size in MB for the different datasets.
The lowest sizes per dataset are indicated in bold.
There is no consistent overall winner.</p>
            </figcaption>
          </figure>

          <figure id="table-ingestion-time" class="table">

            <table>
              <thead>
                <tr>
                  <th>Approach</th>
                  <th style="text-align: right">BEAR-A.</th>
                  <th style="text-align: right">BEAR-B Daily</th>
                  <th style="text-align: right">BEAR-B Hourly</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>OSTRICH</td>
                  <td style="text-align: right">2,256</td>
                  <td style="text-align: right">12.36</td>
                  <td style="text-align: right">4,497.32</td>
                </tr>
                <tr>
                  <td>COBRA</td>
                  <td style="text-align: right">1,300</td>
                  <td style="text-align: right">6.54</td>
                  <td style="text-align: right">529.99</td>
                </tr>
                <tr>
                  <td>COBRA*</td>
                  <td style="text-align: right">1,019</td>
                  <td style="text-align: right">4.91</td>
                  <td style="text-align: right">337.52</td>
                </tr>
                <tr>
                  <td>Jena-IC</td>
                  <td style="text-align: right">443</td>
                  <td style="text-align: right">8.91</td>
                  <td style="text-align: right">142.26</td>
                </tr>
                <tr>
                  <td>Jena-CB</td>
                  <td style="text-align: right">226</td>
                  <td style="text-align: right">9.53</td>
                  <td style="text-align: right">173.48</td>
                </tr>
                <tr>
                  <td>Jena-TB</td>
                  <td style="text-align: right">1,746</td>
                  <td style="text-align: right">0.35</td>
                  <td style="text-align: right">70.56</td>
                </tr>
                <tr>
                  <td>Jena-CB/TB</td>
                  <td style="text-align: right">679</td>
                  <td style="text-align: right">0.35</td>
                  <td style="text-align: right">0.65</td>
                </tr>
                <tr>
                  <td>HDT-IC</td>
                  <td style="text-align: right">34</td>
                  <td style="text-align: right">0.39</td>
                  <td style="text-align: right">5.89</td>
                </tr>
                <tr>
                  <td>HDT-CB</td>
                  <td style="text-align: right"><strong>18</strong></td>
                  <td style="text-align: right"><strong>0.02</strong></td>
                  <td style="text-align: right"><strong>0.07</strong></td>
                </tr>
              </tbody>
            </table>

            <figcaption>
              <p><span class="label">Table 4:</span> Total ingestion time in minutes for the different datasets.
The lowest times per dataset are indicated in bold.</p>
            </figcaption>
          </figure>

          <figure id="ingestion-size" class="figure">

<figure id="ingestion-size-beara" class="subfigure">
<img src="img/results-ingestion-size-beara.svg" alt="[bear-a ingestion sizes]" height="200em" class="plot" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 3.1:</span> BEAR-A</p>
              </figcaption>
</figure>

<figure id="ingestion-size-bearbd" class="subfigure">
<img src="img/results-ingestion-size-bearb-daily.svg" alt="[bear-b-hourly ingestion sizes]" height="200em" class="plot" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 3.2:</span> BEAR-B Daily</p>
              </figcaption>
</figure>

<figure id="ingestion-size-bearbh" class="subfigure">
<img src="img/results-ingestion-size-bearb-hourly.svg" alt="[bear-b-hourly ingestion sizes]" height="200em" class="plot" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 3.3:</span> BEAR-B Hourly</p>
              </figcaption>
</figure>

<figcaption>
              <p><span class="label">Fig. 3:</span> Cumulative storage sizes for BEAR-A, BEAR-B Daily, and BEAR-B Hourly under the different storage approaches.
COBRA requires less storage space than OSTRICH for BEAR-A and BEAR-B Hourly.
The middle snapshot always leads to a significant increase in storage size.
The ingestion of COBRA happens out of order, which means that the middle version is ingested first, up until version 0,
after which all versions after the middle version are ingested in normal order.</p>
            </figcaption>
</figure>

          <figure id="ingestion-time" class="figure">

<figure id="ingestion-time-beara" class="subfigure">
<img src="img/results-ingestion-rate-beara.svg" alt="[bear-a ingestion rate]" height="200em" class="plot" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 4.1:</span> BEAR-A</p>
              </figcaption>
</figure>

<figure id="ingestion-time-bearbd" class="subfigure">
<img src="img/results-ingestion-rate-bearb-daily.svg" alt="[bear-b-hourly ingestion sizes]" height="200em" class="plot" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 4.2:</span> BEAR-B Daily</p>
              </figcaption>
</figure>

<figure id="ingestion-time-bearbh" class="subfigure">
<img src="img/results-ingestion-rate-bearb-hourly.svg" alt="[bear-b-hourly ingestion rate]" height="200em" class="plot" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 4.3:</span> BEAR-B Hourly</p>
              </figcaption>
</figure>

<figure id="ingestion-time-bearbh-log" class="subfigure">
<img src="img/results-ingestion-rate-bearb-hourly-log.svg" alt="[bear-b-hourly ingestion rate with logarithmic axis]" height="200em" class="plot" />
<figcaption class="for-subfigure">
                <p><span class="label">Subfig. 4.4:</span> BEAR-B Hourly (Logarithmic Y axis)</p>
              </figcaption>
</figure>

<figcaption>
              <p><span class="label">Fig. 4:</span> Ingestion times per version for BEAR-A, BEAR-B Daily, and BEAR-B Hourly under the different storage approaches.
COBRA resets ingestion time from the snapshot version, while ingestion time for OSTRICH keeps increasing.
The ingestion of COBRA happens out of order, which means that the middle version is ingested first, up until version 0,
after which all versions after the middle version are ingested in normal order.</p>
            </figcaption>
</figure>

          <p>In order to provide more details on the evolution of storage size and ingestion time of COBRA(*) compared to OSTRICH,
<a href="#ingestion-size">Fig. 3</a> shows the cumulative storage size for the different datasets,
and <a href="#ingestion-time">Fig. 4</a> shows the ingestion time for these datasets.
Note that COBRA is ingested out of order, which means that the first half of the delta chain is ingested first in reverse order,
and the second half of the delta chain is ingested after that in normal order.
These figures show the impact of the middle snapshots within the bidirectional chain.
For BEAR-A, storage size for COBRA lowers in the second half of the delta chain,
which shows that a snapshot with reversed deltas pointing to it (COBRA) requires less storage space
compared to continued use of aggregated deltas (OSTRICH).
For BEAR-B Daily, the storage size significantly increases for the second half of the delta chain,
but for BEAR-B hourly it decreases.
For all datasets, COBRA ingestion times reset to low values from the middle version.
Especially for BEAR-B Hourly we see a significant decrease in ingestion time for COBRA compared to OSTRICH.
While OSTRICH experiences major performance issues from around version 1100,
the ingestion times of COBRA are much lower, which clearly shows the benefit of the bidirectional delta chain.</p>

          <p>Finally, <a href="#ingestion-fixup-time">Table 5</a> shows the fix-up times,
which are measured as a separate offline process,
together with their additional cost relative to out of order ingestion.
The fix-up time is the time it would take to transition from the COBRA* to COBRA storage approach,
when the versions cannot be inserted out of order.
While this fix-up requires only 2.39 times more time relative to the overhead of COBRA compared to COBRA* for BEAR-B Daily,
it requires more than 200 times more time for BEAR-A and BEAR-B Hourly,
which shows that out-of-order ingestion is still preferred when possible.</p>

          <figure id="ingestion-fixup-time" class="table">

            <table>
              <thead>
                <tr>
                  <th>Dataset</th>
                  <th style="text-align: left">Time</th>
                  <th style="text-align: left">Overhead cost</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>BEAR-A</td>
                  <td style="text-align: left">9.52 hours</td>
                  <td style="text-align: left">203.27x</td>
                </tr>
                <tr>
                  <td>BEAR-B Daily</td>
                  <td style="text-align: left">3.91 minutes</td>
                  <td style="text-align: left">2.39x</td>
                </tr>
                <tr>
                  <td>BEAR-B Hourly</td>
                  <td style="text-align: left">7.82 hours</td>
                  <td style="text-align: left">243.78x</td>
                </tr>
              </tbody>
            </table>

            <figcaption>
              <p><span class="label">Table 5:</span> Fix-up duration for the different datasets,
together with its cost relative to the overhead of COBRA compared to COBRA*.</p>
            </figcaption>
          </figure>

          <h4 id="query-evaluation">Query Evaluation</h4>

          <p><a href="#results-beara-vm-sumary">Fig. 5</a>, <a href="#results-beara-dm-summary">Fig. 6</a>, and <a href="#results-beara-vq-summary">Fig. 7</a>
show the query results on BEAR-A for all approaches for respectively VM, DM and VQ.
<a href="#results-bearb-daily-vm-sumary">Fig. 8</a>, <a href="#results-bearb-daily-dm-summary">Fig. 9</a>, and <a href="#results-bearb-daily-vq-summary">Fig. 10</a>
show the same for BEAR-B Daily,
and <a href="#results-bearb-hourly-vm-sumary">Fig. 11</a>, <a href="#results-bearb-hourly-dm-summary">Fig. 12</a>, and <a href="#results-bearb-hourly-vq-summary">Fig. 13</a>
for BEAR-B Hourly.
These query evaluation times are averaged across all query sets for their respective dataset.
For completeness, we included more detailed plots for each query set separately in <a href="#appendix">the appendix</a>.</p>

          <p>When purely comparing COBRA and OSTRICH,
the summarizing figures show that for VM queries, COBRA is faster than OSTRICH in BEAR-A,
but for the BEAR-B datasets, COBRA is slightly faster than OSTRICH for the first half of the delta chain,
and becomes slower in the second half.
For DM, COBRA is always equal or faster than OSTRICH when querying within the first half of its delta chain,
but slower for the second half.
For VQ, COBRA is faster than OSTRICH for BEAR-B Hourly, slightly faster for BEAR-B Daily, and slower for BEAR-A.</p>

          <p>When also including the HDT and Jena approaches,
we see that for VM queries, HDT-IC is overall faster than all other approaches,
and Jena-based approaches are mostly the slowest.
HDT-CB also starts of about as fast as HDT-IC, but becomes slower for later versions,
and even becomes significantly slower than COBRA and OSTRICH for BEAR-B Hourly that has many versions.
For DM queries, HDT-IC is slightly faster than COBRA and OSTRICH.
Again, Jena-based approaches are significantly slower,
and HDT-CB again starts off fast, but becomes slower for later versions.
For VQ queries, COBRA and OSTRICH are faster than all other approaches,
except for BEAR-A where the HDT-based approaches achieve similar performance.</p>

          <figure id="results-beara-vm-sumary">
<img src="img/query/results_beara-vm-summary.svg" alt="[bear-a vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 5:</span> Median BEAR-A VM query results for all triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="results-beara-dm-summary">
<img src="img/query/results_beara-dm-summary.svg" alt="[bear-a dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 6:</span> Median BEAR-A DM query results for all triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="results-beara-vq-summary">
<img src="img/query/results_beara-vq-summary.svg" alt="[bear-a vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 7:</span> Median BEAR-A VQ query results for all triple patterns.</p>
            </figcaption>
</figure>

          <figure id="results-bearb-daily-vm-sumary">
<img src="img/query/results_bearb-daily-vm-summary.svg" alt="[bear-b-daily vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 8:</span> Median BEAR-B-daily VM query results for all triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="results-bearb-daily-dm-summary">
<img src="img/query/results_bearb-daily-dm-summary.svg" alt="[bear-b-daily dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 9:</span> Median BEAR-B-daily DM query results for all triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="results-bearb-daily-vq-summary">
<img src="img/query/results_bearb-daily-vq-summary.svg" alt="[bear-b-daily vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 10:</span> Median BEAR-B-daily VQ query results for all triple patterns.</p>
            </figcaption>
</figure>

          <figure id="results-bearb-hourly-vm-sumary">
<img src="img/query/results_bearb-hourly-vm-summary.svg" alt="[bear-b-hourly vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 11:</span> Median BEAR-B-hourly VM query results for all triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="results-bearb-hourly-dm-summary">
<img src="img/query/results_bearb-hourly-dm-summary.svg" alt="[bear-b-hourly dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 12:</span> Median BEAR-B-hourly DM query results for all triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="results-bearb-hourly-vq-summary">
<img src="img/query/results_bearb-hourly-vq-summary.svg" alt="[bear-b-hourly vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 13:</span> Median BEAR-B-hourly VQ query results for all triple patterns.</p>
            </figcaption>
</figure>

          <h3 id="evaluation-discussion">Result analysis</h3>

          <p>In this section, we discuss the findings of our results regarding ingestion and query evaluation
when comparing the bidirectional delta chain with a unidirectional delta chain,
we test our hypotheses,
and we discuss the overall comparison of different archiving approaches.</p>

          <h4 id="ingestion-1">Ingestion</h4>

          <p>While the unidirectional delta chain leads to increasing ingestion times for every new version,
initiating a new snapshot (COBRA*) can effectively <em>reset</em> these ingestion times,
and lead to overall lower ingestion times.
The downside is that there can be an increase in storage size due to this,
for datasets that have few small or large versions (BEAR-B Daily and BEAR-A).
Otherwise for many small versions (BEAR-B Hourly) there is a decrease in storage size,
because the creation of a new snapshot and delta chain outweighs continuing with the aggregated deltas in terms of storage size.
As such, for datasets that have few small or large versions (BEAR-B Daily and BEAR-A),
it is recommended to wait longer before initiating a new snapshot in the delta chain.
On the other hand, the decrease in storage size for BEAR-B Hourly hints that we could have reduced total storage size
even more by creating the snapshot slightly earlier.
Given the capabilities and query load of the server and affordable storage overhead,
a certain ingestion size and time threshold could be defined,
which would initiate a new snapshot when this threshold is exceeded.</p>

          <p>Once there are two unidirectional delta chains,
the first one could optionally be reversed so that both can share one snapshot through a fix-up process (COBRA).
Our results show that this can further reduce storage size for datasets with few large versions (BEAR-A and BEAR-B Hourly),
and even lead to less storage space compared to the continued use of aggregated deltas (OSTRICH).
However, even though there is a reduction of storage size for many small versions (BEAR-B Daily),
this leads to overhead in terms of storage size compared to the unidirectional delta chain (OSTRICH).
This shows that a bidirectional delta chain is more effective for BEAR-A and BEAR-B Hourly compared to the BEAR-B Daily dataset in terms of storage size,
while it is always effective in terms of ingestion time.
The fix-up process for enabling this reversal does however require a significant execution time.
Since this could easily run in a separate offline process in parallel to query execution and the ingestion of next versions,
this additional time is typically not a problem.
As such, when the server encounters a dataset with large versions (millions of triples per version),
then the fix-up approach should be followed.</p>

          <p>The results also show that if all versions are known beforehand,
they should be ingested out-of-order into a bidirectional delta chain.
Because this leads to a significantly lower total ingestion time
compared to in-order ingestion followed by the fix-up process.</p>

          <h4 id="query-evaluation-1">Query Evaluation</h4>

          <p>Regarding query performance, our results show that the bidirectional delta chain also has a large impact here compared to the unidirectional delta chain.
Since two shorter delta chains lead to two smaller addition and deletion indexes compared to one longer delta chain,
VM and DM times become lower for the dataset with few large versions (BEAR-A), since less data needs to be iterated.
However, for datasets with many small versions (BEAR-B),
we see that VM times become lower or equal for the first half of the bidirectional delta chain,
but become slower for the second half.
We see this behaviour also recurring across all datasets for DM queries.
This is because in these cases we need to query within the two parts of the delta chain,
i.e., we need to search through two addition and deletion indexes instead of just one.
For datasets with many small versions (BEAR-B),
VQ also becomes faster with a bidirectional delta chain,
but this does not apply when the dataset has few large versions (BEAR-A).
This is again caused by the fact that we now have two delta chains,
and two addition and deletion indexes to query in.
When we have many small versions, these two delta chains are worth it,
as the benefit of the shared snapshot outweighs the overhead of the delta chains.
However, for few large versions,
the overhead of two delta chains is too large for VQ,
and one delta chain performs better.
In summary, a bidirectional delta chain is effective for optimizing VM (assuming few large versions),
it can make DM faster for the first half of all versions, but it slows DM down for the second half,
and it is beneficial for VQ (assuming many small versions).</p>

          <h4 id="hypotheses">Hypotheses</h4>

          <p>In <a href="#problem-statement">Section 3</a>, we defined research hypotheses,
which we will now answer based on our experimental results.
In our <a href="#hypothesis-qualitative-storage">first hypothesis</a>, we expected storage size
to become lower with a bidirectional delta chain compared to a unidirectional delta chain.
While this is true for BEAR-A and BEAR-B Hourly, this is not true for BEAR-B Daily.
As such, we <em>reject</em> this hypothesis.
In our <a href="#hypothesis-qualitative-ingestion">second hypothesis</a>,
we expected ingestion time to be lower with a bidirectional delta chain,
which was the primary goal of this work.
Our results show that this is true.
As such, we <em>accept</em> this hypothesis.
Our other hypotheses expect that evaluation times for <a href="#hypothesis-qualitative-querying-vm">VM</a>,
<a href="#hypothesis-qualitative-querying-dm">DM</a> and <a href="#hypothesis-qualitative-querying-vq">VQ</a>
with a bidirectional delta chain would be lower.
Our results show that each one of them is true in many cases, but they are not valid across the board,
so we <em>reject</em> each of them.</p>

          <h4 id="comparison-of-archiving-approaches">Comparison of Archiving Approaches</h4>

          <p>In previous work, it was shown that OSTRICH can speed up VM, DM, and VQ queries on average compared to other RDF archiving approaches,
at the cost of higher ingestion times.
Our experimental results for the new bidirectional delta chain approach from COBRA
show that it can significantly reduce ingestion time, and sometimes also ingestion size.
Even though there are these reductions, there are still approaches for which ingestion is significantly faster (Jena-TB, Jena-CB/TB, HDT-IC, HDT-CB)
and storage size is slightly lower (Jena-TB, Jena-CB/TB, HDT-CB).</p>

          <p>The results show that HDT-based approaches can perform exceptionally well in certain cases,
but they then perform relatively much worse in other cases.
For instance, HDT-IC performs best in all cases for VM queries,
but this comes at the cost of very high storage requirements.
Furthermore, HDT-CB performs really well for all queries,
but becomes continuously slower for more versions in the dataset.
Overall, Jena-based approaches are the slowest.
In general, both OSTRICH and COBRA offer a valuable trade-off between these extremes,
with COBRA focusing on reducing the problematically high ingestion times of OSTRICH.
OSTRICH and COBRA are thereby never the optimal solution for all specific cases,
but they perform –on average– sufficiently well for all different cases,
which is not the case for the other approaches.</p>

        </div>
</section>

  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Conclusions</h2>

          <p>In this work, we improved the storage of RDF archives
under the hybrid storage strategy (OSTRICH)
by making use of a <em>bidirectional delta chain</em>.
Based on our implementation of this new approach (COBRA),
our experimental results show that this modification
leads to more efficient ingestion (59% faster) compared to a unidirectional delta chain (OSTRICH).
This change also reduces total storage size (19% lower) for two out of three datasets.
Furthermore, all versioned query types achieve a performance boost (21% faster),
except for VQ under the BEAR-A dataset.
COBRA offers a more balanced performance trade-off between the different versioned query types and ingestion
compared to other RDF archiving approaches that may perform better in specific cases,
but worse in other cases.
This trade-off, combined with query execution times in the order of 1 millisecond or less,
shows that the bidirectional delta chain strategy from COBRA is an ideal back-end for RDF archives in the context of Web querying,
as network latency is typically slower than that.</p>

          <p>As such, the bidirectional delta chain (COBRA) is a viable alternative to the unidirectional delta chain (OSTRICH),
as it reduces its scalability problems during ingestion while still achieving sufficiently fast querying.
We <strong>recommend bidirectional delta chains</strong> when any of the following is needed (in order of importance):</p>

          <ul>
            <li><strong>Lower ingestion times</strong></li>
            <li><strong>Lower storage sizes</strong></li>
          </ul>

          <p>On the other hand, we <strong>do not recommend bidirectional delta chains</strong> in the following cases:</p>

          <ul>
            <li><strong>Fast VQ is needed over datasets with very large versions</strong>: Bidirectional chains slow down VQ when versions are large.</li>
            <li><strong>Fast VM/DM is needed over datasets with many small versions</strong>: Bidirectional chains slow down VM and DM in the second half for many smaller versions.</li>
            <li><strong>Dataset has only a few small versions</strong>: Unidirectional chain should be used until the ingestion of a new version exceeds the ingestion time of a new snapshot.</li>
          </ul>

          <p>These limitations of a bidirectional delta chain
may be resolvable in future work through more intelligent strategies on
when to convert a unidirectional delta chain into a bidirectional delta chain.
Next to this, the beneficial impact of the bidirectional delta chain opens up questions
as to what respect other transformations of the delta chain in terms of delta directionality and snapshot placement
may be beneficial to ingestion time, storage size, and query performance.
First, deltas may inherit from two or more surrounding versions, instead of just one.
Second, aggregated and non-aggregated deltas are just two extremes of delta organization.
A range of valuable possibilities in between may exist,
such as inheriting from the n<sup>th</sup> largest preceding version.
Third, the impact of multiple snapshots and strategies to decide when to create them still remain as open questions,
which we suspect will be crucial for RDF archiving for indefinitely increasing numbers of versions.
Fourth, the creation of multiple snapshots will also lead to the need for querying across multiple snapshots and delta chains.
While the existing VM querying algorithm can be reused for this,
new efficient algorithms for DM and VQ with offset support will be required,
as well as algorithms for providing cardinality estimates.</p>

          <p>While these findings show that a bidirectional delta chain can be more beneficial than a unidirectional delta chain for the same version range,
neither approach will scale to an infinite number of versions.
Therefore, investigating creation of multiple snapshots in future work to create new delta chains will be crucial for solving scalability issues
when ingesting (theoretically) infinite numbers of version.
While we expect that the creation and querying of multiple delta chains will be significantly more expensive than a single delta chain,
the use of bidirectional chains can delay their need by a factor of 2 compared to unidirectional delta chains.</p>

          <p>We have shown that modifying the structure of the delta chain can be highly beneficial for RDF archiving.
This brings us closer to an efficient queryable Semantic Web that can evolve and maintain its history.</p>

        </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/" typeof="schema:CreativeWork">Cyganiak, R., Wood, D., Lanthaler, M.: RDF 1.1: Concepts and Abstract Syntax. W3C, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">http:/​/​www.w3.org/TR/2014/REC-rdf11-concepts-20140225/</a> (2014).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#datasetdynamics" typeof="schema:Article">Umbrich, J., Decker, S., Hausenblas, M., Polleres, A., Hogan, A.: Towards dataset dynamics: Change frequency of Linked Open Data sources. 3rd International Workshop on Linked Data on the Web (LDOW). (2010).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-540-76298-0_52" typeof="schema:Article">Auer, S., Bizer, C., Kobilarov, G., Lehmann, J., Cyganiak, R., Ives, Z.: Dbpedia: A nucleus for a web of open data. The semantic web. 722–735 (2007).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="http://ceur-ws.org/Vol-1377/paper6.pdf" typeof="schema:Article">Fernández, J.D., Polleres, A., Umbrich, J.: Towards efficient archiving of Dynamic Linked Open Data. In: Proceedings of te First DIACHRON Workshop on Managing the Evolution and Preservation of the Data Web. pp. 34–49 (2015).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2018.08.001" typeof="schema:Article">Taelman, R., Vander Sande, M., Van Herwegen, J., Mannens, E., Verborgh, R.: Triple storage for random-access versioned querying of RDF archives. Journal of Web Semantics. 54, 4–28 (2019).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://dx.doi.org/doi:10.1016/j.websem.2016.03.003" typeof="schema:Article">Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, (2016).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="http://www.w3.org/TR/2013/REC-sparql11-query-20130321/" typeof="schema:CreativeWork">Harris, S., Seaborne, A., Prud’hommeaux, E.: SPARQL 1.1 Query Language. W3C, <a href="http://www.w3.org/TR/2013/REC-sparql11-query-20130321/">http:/​/​www.w3.org/TR/2013/REC-sparql11-query-20130321/</a> (2013).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="https://dx.doi.org/10.3233/SW-210434" typeof="schema:Article">Pelgrin, O., Galàrraga, L., Hose, K.: Towards Fully-fledged Archiving for RDF Datasets. Semantic Web Journal. 1–24 (2020).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="https://dx.doi.org/10.1109/TCSVT.2003.814963" typeof="schema:Article">Flierl, M., Girod, B.: Generalized B pictures and the draft H. 264/AVC video-compression standard. IEEE Transactions on Circuits and Systems for Video technology. 13, 587–597 (2003).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2013.01.002" typeof="schema:Article">Fernández, J.D., Martínez-Prieto, M.A., Gutiérrez, C., Polleres, A., Arias, M.: Binary RDF Representation for Publication and Exchange (HDT). Web Semantics: Science, Services and Agents on the World Wide Web. 19, 22–41 (2013).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="https://dx.doi.org/10.14778/1453856.1453927" typeof="schema:Article">Neumann, T., Weikum, G.: RDF-3X: a RISC-style engine for RDF. Proceedings of the VLDB Endowment. 1, 647–659 (2008).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="https://dx.doi.org/10.3233/SW-180309" typeof="schema:Article">Fernández, J.D., Umbrich, J., Polleres, A., Knuth, M.: Evaluating Query and Storage Strategies for RDF Archives. Semantic Web Journal. (2018).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="http://rubensworks.net/raw/publications/2016/ExposingRdfArchivesUsingTpf.pdf" typeof="schema:Article">Taelman, R., Verborgh, R., Mannens, E.: Exposing RDF Archives using Triple Pattern Fragments. In: Proceedings of the 20th International Conference on Knowledge Engineering and Knowledge Management: Posters and Demos (2016).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2018.08.002" typeof="schema:Article">Arndt, N., Naumann, P., Radtke, N., Martin, M., Marx, E.: Decentralized Collaborative Knowledge Management using Git. Journal of Web Semantics. (2018).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="#semversion" typeof="schema:Article">Volkel, M., Winkler, W., Sure, Y., Kruk, S.R., Synak, M.: Semversion: A versioning system for RDF and ontologies. In: Second European Semantic Web Conference, ESWC 2005, Heraklion, Crete, Greece, May 29–June 1, 2005. Proceedings (2005).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="#vcrdf" typeof="schema:Article">Cassidy, S., Ballantine, J.: Version Control for RDF Triple Stores. ICSOFT (ISDM/EHST/DC). 7, 5–12 (2007).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="#rwbase" typeof="schema:Article">Vander Sande, M., Colpaert, P., Verborgh, R., Coppens, S., Mannens, E., Van de Walle, R.: R&amp;Wbase: git for triples. In: Proceedings of the 6th Workshop on Linked Data on the Web (2013).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="#r43ples" typeof="schema:Article">Graube, M., Hensel, S., Urbas, L.: R43ples: Revisions for triples. In: Proceedings of the 1st Workshop on Linked Data Quality co-located with 10th International Conference on Semantic Systems (SEMANTiCS 2014) (2014).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="#vcld" typeof="schema:Article">Hauptmann, C., Brocco, M., Wörndl, W.: Scalable Semantic Version Control for Linked Data Management. In: Proceedings of the 2nd Workshop on Linked Data Quality co-located with 12th Extended Semantic Web Conference (ESWC 2015) (2015).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="https://dx.doi.org/10.14778/1920841.1920877" typeof="schema:Article">Neumann, T., Weikum, G.: x-RDF-3X: fast querying, high update rates, and consistency for RDF databases. Proceedings of the VLDB Endowment. 3, 256–263 (2010).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="https://pdfs.semanticscholar.org/8efc/acc920a6329bda5508c65c84d69f52eb5ac1.pdf" typeof="schema:Article">Gao, S., Gu, J., Zaniolo, C.: RDF-TX: A fast, user-friendly system for querying the history of RDF knowledge bases. In: Proceedings of the 19th International Conference on Extending DatabaseTechnology. pp. 269–280 (2016).</dd>
  <dt id="ref-22">[22]</dt>
  <dd resource="https://dx.doi.org/10.1109/DCC.2016.40" typeof="schema:Article">Cerdeira-Pena, A., Farina, A., Fernández, J.D., Martı́nez-Prieto Miguel A: Self-indexing RDF archives. In: Data Compression Conference (DCC), 2016. pp. 526–535. IEEE (2016).</dd>
  <dt id="ref-23">[23]</dt>
  <dd resource="#dydra" typeof="schema:Article">Anderson, J., Bendiken, A.: Transaction-time queries in dydra. In: Joint Proceedings of the 2nd Workshop on Managing the Evolution and Preservation of the Data Web (MEPDaW 2016) and the 3rd Workshop on Linked Data Quality (LDQ 2016). pp. 11–19 (2016).</dd>
  <dt id="ref-24">[24]</dt>
  <dd resource="https://dx.doi.org/10.1145/2814864.2814875" typeof="schema:Article">Meinhardt, P., Knuth, M., Sack, H.: TailR: a platform for preserving history on the web of data. In: Proceedings of the 11th International Conference on Semantic Systems. pp. 57–64. ACM (2015).</dd>
  <dt id="ref-25">[25]</dt>
  <dd resource="https://users.dcc.uchile.cl/~ahogan/docs/sparql-version.pdf" typeof="schema:Article">Cuevas, I., Hogan, A.: Versioned Queries over RDF Archives: All You Need is SPARQL? In: Proceedings of the Workshop on Managing the Evolution and Preservation of the Data Web (MEPDaW) (2020).</dd>
  <dt id="ref-26">[26]</dt>
  <dd resource="https://dx.doi.org/10.1142/S0218194012500040" typeof="schema:Article">Im, D.-H., Lee, S.-W., Kim, H.-J.: A version management framework for RDF triple stores. International Journal of Software Engineering and Knowledge Engineering. 22, 85–106 (2012).</dd>
  <dt id="ref-27">[27]</dt>
  <dd resource="https://dx.doi.org/10.1109/MIC.2002.1067737" typeof="schema:Article">McBride, B.: Jena: A semantic web toolkit. IEEE Internet computing. 6, 55–59 (2002).</dd>
  <dt id="ref-28">[28]</dt>
  <dd resource="http://rubensworks.net/raw/publications/2017/vtpf.pdf" typeof="schema:Article">Taelman, R., Vander Sande, M., Verborgh, R., Mannens, E.: Versioned Triple Pattern Fragments: A Low-cost Linked Data Interface Feature for Web Archives. In: Proceedings of the 3rd Workshop on Managing the Evolution and Preservation of the Data Web (2017).</dd>
  <dt id="ref-29">[29]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-030-00668-6_15" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-30">[30]</dt>
  <dd resource="https://rdfostrich.github.io/article-mocha-2018/" typeof="schema:Article">Taelman, R., Vander Sande, M., Verborgh, R.: Versioned Querying with OSTRICH and Comunica in MOCHA 2018. In: Proceedings of the 5th SemWebEval Challenge at ESWC 2018 (2018).</dd>
  <dt id="ref-31">[31]</dt>
  <dd resource="https://dx.doi.org/10.1002/spe.4380150703" typeof="schema:Article">Tichy, W.F.: RCS—a system for version control. Software: Practice and Experience. 15, 637–654 (1985).</dd>
  <dt id="ref-32">[32]</dt>
  <dd resource="http://darcs.net" typeof="schema:CreativeWork">Roundy, D.: Darcs. <a href="http://darcs.net">http:/​/​darcs.net</a> (2008).</dd>
</dl>
</section>
</footer>

<br />
<br />

<div id="appendix">
      <h1 id="appendix">Appendix</h1>
      <section id="appendix-bear-a" inlist="" rel="schema:hasPart" resource="#appendix-bear-a">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">BEAR-A Query Evaluation results</h2>

          <p>In this appendix section, we list all measured BEAR-A query evaluation durations.
Each figure contains the durations for each storage approach, being
OSTRICH, COBRA, HDT-IC, HDT-CB, Jena-IC, Jena-CB, Jena-TB and Jena-CB/TB.</p>

          <figure id="result_beara-vm-s-low">
<img src="img/query/result_beara-vm-s-low.svg" alt="[bear-a S?? low vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 14:</span> Average VM query results for S?? triple patterns with a low cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-s-high">
<img src="img/query/result_beara-vm-s-high.svg" alt="[bear-a S?? high vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 15:</span> Average VM query results for S?? triple patterns with a high cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-p-low">
<img src="img/query/result_beara-vm-p-low.svg" alt="[bear-a ?P? low vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 16:</span> Average VM query results for ?P? triple patterns with a low cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-p-high">
<img src="img/query/result_beara-vm-p-high.svg" alt="[bear-a ?P? high vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 17:</span> Average VM query results for ?P? triple patterns with a high cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-o-low">
<img src="img/query/result_beara-vm-o-low.svg" alt="[bear-a ??O low vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 18:</span> Average VM query results for ??O triple patterns with a low cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-o-high">
<img src="img/query/result_beara-vm-o-high.svg" alt="[bear-a ??O high vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 19:</span> Average VM query results for ??O triple patterns with a high cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-sp-low">
<img src="img/query/result_beara-vm-sp-low.svg" alt="[bear-a SP? low vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 20:</span> Average VM query results for SP? triple patterns with a low cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-sp-high">
<img src="img/query/result_beara-vm-sp-high.svg" alt="[bear-a SP? high vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 21:</span> Average VM query results for SP? triple patterns with a high cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-so-low">
<img src="img/query/result_beara-vm-so-low.svg" alt="[bear-a S?O low vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 22:</span> Average VM query results for S?O triple patterns with a low cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-po-low">
<img src="img/query/result_beara-vm-po-low.svg" alt="[bear-a ?PO low vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 23:</span> Average VM query results for ?PO triple patterns with a low cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-po-high">
<img src="img/query/result_beara-vm-po-high.svg" alt="[bear-a ?PO high vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 24:</span> Average VM query results for ?PO triple patterns with a high cardinality for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vm-spo">
<img src="img/query/result_beara-vm-spo.svg" alt="[bear-a SPO vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 25:</span> Average VM query results for SPO triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-s-low">
<img src="img/query/result_beara-dm-s-low.svg" alt="[bear-a S?? low dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 26:</span> Average DM query results for S?? triple patterns with a low cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-s-high">
<img src="img/query/result_beara-dm-s-high.svg" alt="[bear-a S?? high dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 27:</span> Average DM query results for S?? triple patterns with a high cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-p-low">
<img src="img/query/result_beara-dm-p-low.svg" alt="[bear-a ?P? low dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 28:</span> Average DM query results for ?P? triple patterns with a low cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-p-high">
<img src="img/query/result_beara-dm-p-high.svg" alt="[bear-a ?P? high dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 29:</span> Average DM query results for ?P? triple patterns with a high cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-o-low">
<img src="img/query/result_beara-dm-o-low.svg" alt="[bear-a ??O low dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 30:</span> Average DM query results for ??O triple patterns with a low cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-o-high">
<img src="img/query/result_beara-dm-o-high.svg" alt="[bear-a ??O high dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 31:</span> Average DM query results for ??O triple patterns with a high cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-sp-low">
<img src="img/query/result_beara-dm-sp-low.svg" alt="[bear-a SP? low dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 32:</span> Average DM query results for SP? triple patterns with a low cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-sp-high">
<img src="img/query/result_beara-dm-sp-high.svg" alt="[bear-a SP? high dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 33:</span> Average DM query results for SP? triple patterns with a high cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-so-low">
<img src="img/query/result_beara-dm-so-low.svg" alt="[bear-a S?O low dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 34:</span> Average DM query results for S?O triple patterns with a low cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-po-low">
<img src="img/query/result_beara-dm-po-low.svg" alt="[bear-a ?PO low dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 35:</span> Average DM query results for ?PO triple patterns with a low cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-po-high">
<img src="img/query/result_beara-dm-po-high.svg" alt="[bear-a ?PO high dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 36:</span> Average DM query results for ?PO triple patterns with a high cardinality from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-dm-spo">
<img src="img/query/result_beara-dm-spo.svg" alt="[bear-a SPO dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 37:</span> Average DM query results for SPO triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-s-low">
<img src="img/query/result_beara-vq-s-low.svg" alt="[bear-a S?? low vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 38:</span> Average VQ query results for S?? triple patterns with a low cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-s-high">
<img src="img/query/result_beara-vq-s-high.svg" alt="[bear-a S?? high vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 39:</span> Average VQ query results for S?? triple patterns with a high cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-p-low">
<img src="img/query/result_beara-vq-p-low.svg" alt="[bear-a ?P? low vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 40:</span> Average VQ query results for ?P? triple patterns with a low cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-p-high">
<img src="img/query/result_beara-vq-p-high.svg" alt="[bear-a ?P? high vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 41:</span> Average VQ query results for ?P? triple patterns with a high cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-o-low">
<img src="img/query/result_beara-vq-o-low.svg" alt="[bear-a ??O low vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 42:</span> Average VQ query results for ??O triple patterns with a low cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-o-high">
<img src="img/query/result_beara-vq-o-high.svg" alt="[bear-a ??O high vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 43:</span> Average VQ query results for ??O triple patterns with a high cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-sp-low">
<img src="img/query/result_beara-vq-sp-low.svg" alt="[bear-a SP? low vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 44:</span> Average VQ query results for SP? triple patterns with a low cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-sp-high">
<img src="img/query/result_beara-vq-sp-high.svg" alt="[bear-a SP? high vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 45:</span> Average VQ query results for SP? triple patterns with a high cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-so-low">
<img src="img/query/result_beara-vq-so-low.svg" alt="[bear-a S?O low vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 46:</span> Average VQ query results for S?O triple patterns with a low cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-po-low">
<img src="img/query/result_beara-vq-po-low.svg" alt="[bear-a ?PO low vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 47:</span> Average VQ query results for ?PO triple patterns with a low cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-po-high">
<img src="img/query/result_beara-vq-po-high.svg" alt="[bear-a ?PO high vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 48:</span> Average VQ query results for ?PO triple patterns with a high cardinality.</p>
            </figcaption>
</figure>

          <figure id="result_beara-vq-spo">
<img src="img/query/result_beara-vq-spo.svg" alt="[bear-a SPO vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 49:</span> Average VQ query results for SPO triple patterns.</p>
            </figcaption>
</figure>
        </div>
</section>

      <section id="appendix-bear-b-daily" inlist="" rel="schema:hasPart" resource="#appendix-bear-b-daily">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">BEAR-B-daily Query Evaluation results</h2>

          <p>In this appendix section, we list all measured BEAR-B-daily query evaluation durations.
Each figure contains the durations for each storage approach, being
OSTRICH, COBRA, HDT-IC, HDT-CB, Jena-IC, Jena-CB, Jena-TB and Jena-CB/TB.</p>

          <figure id="result_bearb-daily-vm-p">
<img src="img/query/result_bearb-daily-vm-p.svg" alt="[bear-b-daily ?P? vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 50:</span> Average VM query results for ?P? triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-daily-vm-po">
<img src="img/query/result_bearb-daily-vm-po.svg" alt="[bear-b-daily ?PO vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 51:</span> Average VM query results for ?PO triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-daily-dm-p">
<img src="img/query/result_bearb-daily-dm-p.svg" alt="[bear-b-daily ?P? dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 52:</span> Average DM query results for ?P? triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-daily-dm-po">
<img src="img/query/result_bearb-daily-dm-po.svg" alt="[bear-b-daily ?PO dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 53:</span> Average DM query results for ?PO triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-daily-vq-p">
<img src="img/query/result_bearb-daily-vq-p.svg" alt="[bear-b-daily ?P? vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 54:</span> Average VQ query results for ?P? triple patterns.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-daily-vq-po">
<img src="img/query/result_bearb-daily-vq-po.svg" alt="[bear-b-daily ?PO vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 55:</span> Average VQ query results for ?PO triple patterns.</p>
            </figcaption>
</figure>
        </div>
</section>

      <section id="appendix-bear-b-hourly" inlist="" rel="schema:hasPart" resource="#appendix-bear-b-hourly">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">BEAR-B-hourly Query Evaluation results</h2>

          <p>In this appendix section, we list all measured BEAR-B-hourly query evaluation durations.
Each figure contains the durations for each storage approach, being
OSTRICH, COBRA, HDT-IC, HDT-CB, Jena-IC, Jena-CB, Jena-TB and Jena-CB/TB.</p>

          <figure id="result_bearb-hourly-vm-p">
<img src="img/query/result_bearb-hourly-vm-p.svg" alt="[bear-b-hourly ?P? vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 56:</span> Average VM query results for ?P? triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-hourly-vm-po">
<img src="img/query/result_bearb-hourly-vm-po.svg" alt="[bear-b-hourly ?PO vm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 57:</span> Average VM query results for ?PO triple patterns for all versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-hourly-dm-p">
<img src="img/query/result_bearb-hourly-dm-p.svg" alt="[bear-b-hourly ?P? dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 58:</span> Average DM query results for ?P? triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-hourly-dm-po">
<img src="img/query/result_bearb-hourly-dm-po.svg" alt="[bear-b-hourly ?PO dm]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 59:</span> Average DM query results for ?PO triple patterns from version 0 to all other versions.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-hourly-vq-p">
<img src="img/query/result_bearb-hourly-vq-p.svg" alt="[bear-b-hourly ?P? vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 60:</span> Average VQ query results for ?P? triple patterns.</p>
            </figcaption>
</figure>

          <figure id="result_bearb-hourly-vq-po">
<img src="img/query/result_bearb-hourly-vq-po.svg" alt="[bear-b-hourly ?PO vq]" height="200em" class="plot" />
<figcaption>
              <p><span class="label">Fig. 61:</span> Average VQ query results for ?PO triple patterns.</p>
            </figcaption>
</figure>
        </div>
</section>

    </div>

</div>
</div>



</body>
</html>
